"""Receive messages over from RabbitMQ and send them over the websocket."""

import sys
import os

import pika
import uwsgi


def application(env, start_response):
    """Setup the Websocket Server and read messages off the queue."""
    
    credentials = pika.PlainCredentials(os.environ.get("RABBITMQ_DEFAULT_USER", "guest"), os.environ.get("RABBITMQ_DEFAULT_PASS", ""))

    connection = pika.BlockingConnection(
        pika.ConnectionParameters(host=os.environ.get("RABBITMQ_HOST", "localhost"), port=5672, credentials=credentials, blocked_connection_timeout=30)
    )

    channel = connection.channel()

    exchange = env["PATH_INFO"].replace("/", "")

    channel.exchange_declare(
        exchange=exchange, exchange_type="fanout"
    )

    # exclusive means the queue should be deleted once the connection is closed
    result = channel.queue_declare("", exclusive=True)
    queue_name = result.method.queue  # random queue name generated by RabbitMQ

    # queue_name = "chat"

    channel.queue_bind(exchange=exchange, queue=queue_name)

    uwsgi.websocket_handshake(
        env["HTTP_SEC_WEBSOCKET_KEY"],
        env.get("HTTP_ORIGIN", "")
    )

    def keepalive():
        """Keep the websocket connection alive (called every 30 seconds)."""
        print("PING/PONG...")
        try:
            uwsgi.websocket_recv_nb()
            connection.add_on_connection_blocked_callback(keepalive)
        except OSError as error:
            print(error)
            sys.exit(1) # Kill process and force uWSGI to Respawn

    keepalive()

    while True:
        for method_frame, _, body in channel.consume(queue_name):
            try:
                uwsgi.websocket_send(body)
            except OSError as error:
                print(error)
                sys.exit(1)  # Force uWSGI to Respawn
            else:
                # acknowledge the message
                channel.basic_ack(method_frame.delivery_tag)